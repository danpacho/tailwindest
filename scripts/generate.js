import { JSDOM } from "jsdom";
import { relative } from "node:path";
import { writeFileSync } from "node:fs";

const ENTRY = "https://tailwindcss.com/docs";
const OUTFILE = "packages/tailwindest/__tests__/TailwindTypes.out.ts";

/**
 * Builds a file that looks like
 *
 * export type AspectRatio =
 *    | "aspect-auto"
 *    | "aspect-square"
 *    | "aspect-video"
 *    | "aspect-[4/3]"
 *
 * export type Container =
 *    | "container"
 *    | "sm"
 *    | "md"
 *    | "lg"
 *    | "xl"
 *    | "2xl"
 *
 * // ...
 *
 * export type TailwindTypes =
 *    | AspectRatio
 *    | Container ...
 *
 * export default TailwindTypes
 */

// docs pages to skip
const ignoredPages = [
    "installation",
    "editor-setup",
    "using-with-preprocessors",
    "optimizing-for-production",
    "browser-support",
    "upgrade-guide",

    "utility-first",
    "hover-focus-and-other-states",
    "responsive-design",
    "dark-mode",
    "reusing-styles",
    "adding-custom-styles",
    "functions-and-directives",

    "configuration",
    "content-configuration",
    "theme",
    "screens",
    "customizing-colors",
    "customizing-spacing",
    "plugins",
    "presets",

    "preflight",
].map(p => `${ENTRY}/${p}`);

// classes to drop from oddly formed tables
const ignoredClasses = new Set([
    // from https://tailwindcss.com/docs/container
    ...[ "2xl", "lg", "md", "sm", "xl" ],
]);

const scrape = async (url) => JSDOM.fromURL(url).then(root => root.window.document);

const scrapeClasses = (addClass, page) => {
    page.querySelectorAll("#class-table td:first-child").forEach(addClass);
};

const scrapeArbitraryValues = (addClass, page) => {
    let node = page.getElementById("arbitrary-values")?.nextElementSibling;

    while (node) {
        // stop when we hit section
        if (node.id) break;

        node.querySelectorAll("pre span.code-highlight").forEach(addClass);

        node = node.nextElementSibling;
    }
};

const scrapePage = async (pages, url) => {
    if (ignoredPages.includes(url)) return;
    if (pages.has(url)) return;

    const page = await scrape(url);
    const classes = new Set();

    const addClass = (node) => {
        // get direct text (not text of children)
        const classname = [...node.childNodes].reduce((s, t) => s + (t.nodeType === 3? t.textContent: ""), "").trim();

        if (!ignoredClasses.has(classname)) classes.add(classname);
    };

    scrapeClasses(addClass, page);
    scrapeArbitraryValues(addClass, page);

    pages.set(url, classes)

    return classes;
}

const dashedToPascal = (str) => str.toLowerCase().split("-").map(s => s.substring(0, 1).toUpperCase() + s.substring(1)).join("")

const main = async (entry) => {
    const data = (await scrape(entry)).querySelectorAll("#nav a[href*=\"/docs/\"]");

    let skipped = 0;
    const pages = new Map();
    const classes = new Set();
    const text = [`// Autogenerated with ${relative(process.cwd(), process.argv[1])}`];

    for await (const page of data) {
        const url = new URL(page.getAttribute("href") ?? "", entry).href;

        process.stdout.write(`${url.split("/").at(-1)} ${pages.size+1}/${data.length - skipped} `);

        const temp = await scrapePage(pages, url);

        if (!temp) {
            skipped += 1;
            console.log("skipped");
            continue;
        };

        console.log(temp.size);

        for (const val of temp)
        {
            if (classes.has(val)) console.warn(`already encountered ${val}`);
            classes.add(val);
        }
    }

    const pushType = (name, types) =>
    {
        text.push("", `export type ${name} =`, ...[...types].sort().map(t => `    | ${t}`));
    }

    for (const [url, classes] of pages.entries()) {
        if (classes.size === 0) continue;

        pushType(dashedToPascal(url.split("/").at(-1)), [...classes.values()].map(c => `"${c}"`));
    }

    pushType("TailwindTypes", [...pages.keys()].map(s => dashedToPascal(s.split("/").at(-1))));

    text.push("", "export default TailwindTypes;", "");

    writeFileSync(OUTFILE, text.join("\n"));
}

main(ENTRY).catch(e => console.error(e));
