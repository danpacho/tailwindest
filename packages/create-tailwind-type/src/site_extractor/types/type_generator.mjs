import fs from "fs/promises"
import path from "node:path"
import process from "process"
import { ensureFileExists } from "../util/fs.mjs"
import { TailwindScraper } from "../scraper.mjs"

export class TailwindDocumentationGenerator {
    /**
     * @param {TailwindScraper} scraper - An instance of TailwindScraper to use.
     * @param {string} entryUrl - The base URL for Tailwind documentation (e.g., https://tailwindcss.com/docs).
     * @param {string} outFile - The path where generated type definitions should be saved.
     */
    constructor(scraper, entryUrl, outFile) {
        this.scraper = scraper
        this.entryUrl = entryUrl
        this.outFile = outFile
        this.pagesMap = new Map() // Maps URL -> Set of classes
        this.allClasses = new Set()
    }

    /**
     * Converts a dashed string into PascalCase (e.g. "aspect-ratio" -> "AspectRatio").
     * @param {string} str - The dashed string to convert.
     * @returns {string} - The PascalCase version of the string.
     */
    _dashedToPascal(str) {
        return str
            .toLowerCase()
            .split("-")
            .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
            .join("")
    }

    /**
     * Fetches the root entry page, scrapes all `a[href*="/docs/"]`, and returns their absolute URLs.
     * @returns {Promise<string[]>} - Array of full URLs found in the docs navigation.
     */
    async _fetchDocumentationLinks() {
        const LINK_SELECTOR = 'a[href*="/docs/"]'
        try {
            const doc = await this.scraper.fetchDOM(this.entryUrl)
            if (!doc) {
                console.error(`Failed to fetch ${this.entryUrl}`)
                return []
            }
            const linkElements = doc.querySelectorAll(LINK_SELECTOR)
            /**
             * @type {string[]}
             */
            const urls = []

            linkElements.forEach((el) => {
                const href = el.getAttribute("href") || ""
                // Construct absolute URL
                const url = new URL(href, this.entryUrl).href
                urls.push(url)
            })

            return urls
        } catch (err) {
            throw new Error(
                `Failed to scrape doc info from ${this.entryUrl}:`,
                {
                    cause: err,
                }
            )
        }
    }

    /**
     * Scrapes all relevant pages in parallel and populates `this.pagesMap` and `this.allClasses`.
     * @returns {Promise<void>} - Resolves when all pages have been scraped.
     */
    async scrapeAllPages() {
        const urls = await this._fetchDocumentationLinks()

        // Scrape pages in parallel
        const results = await Promise.all(
            urls.map(async (url) => {
                const setOfClasses = await this.scraper.scrapeClasses(url, true)
                return { url, setOfClasses }
            })
        )

        let processedCount = 0
        let skippedCount = 0

        for (const { url, setOfClasses } of results) {
            if (!setOfClasses) {
                skippedCount++
            } else {
                // Add to pages map
                this.pagesMap.set(url, setOfClasses)
                // Accumulate into global set
                for (const cls of setOfClasses) {
                    if (this.allClasses.has(cls)) {
                        console.warn(
                            `Warning: Duplicate class encountered: ${cls}`
                        )
                    }
                    this.allClasses.add(cls)
                }
                processedCount++
            }
        }

        console.log(
            `\nScraping complete. Processed ${processedCount} pages, Skipped ${skippedCount} pages. Found a total of ${this.allClasses.size} unique classes.\n`
        )
    }

    /**
     * Builds TypeScript type definitions from the collected classes.
     * @returns {string} - The full type definition file as a string.
     */
    _buildTypeDefinitions() {
        /**
         * @type {string[]}
         */
        const lines = [
            `// Autogenerated by: ${path.relative(process.cwd(), process.argv[1])}`,
        ]

        /**
         * Local helper to append a type definition block.
         * @param {string} typeName - The name of the type alias.
         * @param {string[]} types - The string literal types to include (one per line).
         */
        const pushType = (typeName, types) => {
            lines.push(
                "",
                `export type ${typeName} =`,
                ...types.map((t) => `    | ${t}`)
            )
        }

        /**
         * @param {string} type
         */
        const toLiteral = (type) => {
            if (type.includes("${string}")) {
                return `(${"`" + type + "`"} & {})`
            }
            return `"${type}"`
        }

        // Generate sub-types for each doc page, just like before:
        for (const [url, classesSet] of this.pagesMap) {
            if (classesSet.size === 0) continue

            const dashedName = url.split("/").at(-1) || ""
            const pascalName = this._dashedToPascal(dashedName)
            const sortedClasses = [...classesSet].sort()

            // e.g. export type AspectRatio = | "aspect-auto" | "aspect-square" ...
            pushType(pascalName, sortedClasses.map(toLiteral))
        }

        // Generate a union of all *type aliases* if you still want that:
        const allPageTypes = [...this.pagesMap.keys()].map((url) => {
            const dashedName = url.split("/").at(-1) || ""
            return this._dashedToPascal(dashedName)
        })

        pushType("TailwindTypes", allPageTypes)

        // Generate a single BIG union of *all class names* across all pages.
        const globalClassSet = new Set()
        for (const classesSet of this.pagesMap.values()) {
            for (const className of classesSet) {
                globalClassSet.add(className)
            }
        }

        const globalClassesArray = [...globalClassSet].sort()
        // e.g. export type TailwindClassNames = | "aspect-auto" | "aspect-square" | ...
        pushType("TailwindClassNames", globalClassesArray.map(toLiteral))

        lines.push("", "export default TailwindClassNames;", "")
        return lines.join("\n")
    }

    /**
     * Writes the generated TypeScript definitions to the output file.
     * @returns {Promise<void>} - Resolves when the file write operation completes.
     */
    async writeOutputFile() {
        await ensureFileExists(this.outFile)
        const typeDefs = this._buildTypeDefinitions()
        await fs.writeFile(this.outFile, typeDefs, "utf8")
        console.log(`Type definitions written to: ${this.outFile}`)
    }

    /**
     * Orchestrates scraping all pages and generating the final TypeScript definition file.
     * @returns {Promise<void>}
     */
    async generate() {
        await this.scrapeAllPages()
        await this.writeOutputFile()
    }
}
