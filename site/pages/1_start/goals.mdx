import { Callout } from "nextra-theme-docs"
import { Underline } from "~components/common"

# Design goals

## 1. Fully-typed

**Ex1) get all `tailwind` classname**

```ts
type TailwindClass = Tailwindest[keyof Tailwindest]
```

<img src="./../../images/tailwindest.type.png" width="550px" />

**Ex2) access infinite nest condition**

`typescript`'s recursive type computation allows you to write infinite Nested Break conditions.

```ts
const infinite = wind({
    "::after": {
        "::before": {
            "::file": {
                "::first-letter": {
                    "::first-line": {
                        "::marker": {
                            "::placeholder": {
                                "::selection": {
                                    ":active": {
                                        ":autofill": {
                                            backgroundColor:
                                                "after:before:file:first-letter:first-line:marker:placeholder:selection:active:autofill:bg-amber-100",
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            },
        },
    },
})
```

## 2. Readable

Readability is core goal of this project.
To achieve this, design an **<Underline>intuitive</Underline>, <Underline>primitive</Underline>, <Underline>familiar</Underline> API** is essential process.

Final conclusion is going back to the most primitive form, as if we were writing down pure `CSS`. And this led to the conclusion that the CSS in JS form is the best fit.

<Callout type="info">
    Most of the `tailwindcss` **properties name is based on pure `CSS`
    properties,** except `tailwind`'s sole utility properties like `mx-1`.
</Callout>

```ts
const box = wind({
    display: "flex",
    flexDirection: "flex-row",
    alignItems: "items-center",
    justifyContent: "justify-center",

    gap: "gap-2",

    marginX: "mx-2",
})
```

### Colocate nest conditions

In pure `tailwind`, you should write nest conditions like this.

```ts
const smConditions =
    "sm:flex sm:items-center sm:justify-center sm:p-2 sm:m-2 sm:border sm:rounded-sm"
```

As you can see, the `sm:` expression is repeated. But in `tailwindest`, you can colocate nest conditions in one `object`.

```ts
const easyToRead = wind({
    "@sm": {
        display: "sm:flex",
        alignItems: "sm:items-center",
        justifyContent: "sm:justify-center",

        padding: "sm:p-2",
        margin: "sm:m-2",

        borderWidth: "sm:border",
        borderRadius: "sm:rounded-sm",
    },
})
```

<Callout>
    Access nest conditions via autocompletion.

    ```ts
    wind({
        '@dark': {
            ':hover': {
                // type red3 ‚ñ∂Ô∏è get full string
                backgroundColor: 'dark:hover:bg-red-300';
            }
        }
    })
    ```

</Callout>

## 3. Reusable

`tailwindest` handles `strings`. That means, we can reuse all the elements of function.

### Reuse all elements

```ts
const box = wind({
    display: "flex",
    flexDirection: "flex-row",
    alignItems: "items-center",
    justifyContent: "justify-center",
    gap: "gap-2",
})
```

1. <Underline>classname</Underline>: **`string`**

    get classname

    ```ts
    const boxClass = box.class()
    // flex flex-row items-center justify-center gap-2
    ```

2. <Underline>styleSheet</Underline>: **`object`**{" "}

    extract styleSheet

    ```ts
    const boxStyle = box.style()
    /**
    {
        display: "flex",
        flexDirection: "flex-row",
        alignItems: "items-center",
        justifyContent: "justify-center",
        gap: "gap-2",
    }
    **/
    ```

**`classname` and `styleSheet` are just `string` and `object`.** So you can
modifying it whatever you want.

## It's time to dive üèÑ

Now, you are ready to dive in. Let's get into it!
